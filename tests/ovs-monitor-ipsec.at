# WAIT_FOR_TUNNEL_TO_UPDATE([tunnel], [version], [state])
#
# This macro should be called after ovs-vsctl command that updated
# IPsec configuration in OVSDB.  It basically serves as synchronization
# barrier to ensures that ovs-monitor-ipsec daemon's internal configuration
# for 'tunnel' has updated to 'version' and is in 'state'.
m4_define([WAIT_FOR_TUNNEL_TO_UPDATE], [
OVS_WAIT_UNTIL([ovs-appctl -t ovs-monitor-ipsec tunnels/show | grep "Interface name: $1 v$2 ($3"])
])


# WAIT_FOR_PROPER_IPSEC_CLEANUP([])
#
# This macro should be called *only* after all IPsec tunnels were removed
# from OVSDB Interface table.  This macro verifies that:
# 1) ovs-monitor-ipsec daemon thinks that there are no IPsec tunnels
# 2) ipsec.conf file does not contain any tunnels
# 3) ipsec.secrets does not contain any 'secrets' for any tunnels
# 4) ipsec.d directory does not contain any certificates that were
#    previously created by ovs-monitor-ipsec daemon
m4_define([WAIT_FOR_PROPER_IPSEC_CLEANUP], [
OVS_WAIT_UNTIL([ovs-appctl -t ovs-monitor-ipsec tunnels/show | grep "No tunnels configured with IPsec"])
AT_CHECK([cat etc/ipsec.secrets], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!

])
AT_CHECK([cat etc/ipsec.conf], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!


config setup
    uniqueids=no

conn %default
    keyingtries=%forever
    type=transport
    keyexchange=ikev2
    auto=route
    mark_in=1/1
    ike=aes128gcm12-aesxcbc-modp1024
    esp=aes128gcm12-modp1024

])
AT_CHECK([ls etc/ipsec.d/certs], [0], [dnl])
])


# VERIFY_IPSEC_COMMANDS_EXECUTED([ipsec_commands])
#
# This macro alows to verify that ovs-monitor-ipsec daemon called correct
# 'ipsec' commands.  All ipsec commands are logged by a script that mocks
# 'ipsec' utility.
# This macro filters out "ipsec rereadsecrets" and "ipsec status"
# commands.
m4_define([VERIFY_IPSEC_COMMANDS_EXECUTED], [
AT_CHECK([egrep -v "ipsec status|ipsec rereadsecrets" actions], [0], [$1])
])


# INIT_SSL_CERTS([])
#
# This macro creates sample SSL certificates so that it would be
# possible to test tunnels that use "use_ssl_certs" setting.  Don't
# use these certificates in production.
m4_define([INIT_SSL_CERTS], [
AT_DATA([ssl_key.pem], [
-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEAxd9ZkUK+sBToEb8x1LSoMfVPw+l4ww915BNn/0TSA7yY+lq/
k14+FYHFdqB9vSh5C0bUdhrE7QJ451WP8NyTDIUuZlieUBzonXy0hYVBQ8bUSGfF
go/4IWb/tHKIlTiZ86GqaBc8uddiZ7cF2beZwv9un9ZHOGtQrvMdzB7FzmzZraJ1
NbAsr1GX4w0euBjPbUyu96nzBeKWqX3vdERK1ddL5y8hA2kSUslci60zCf9/jvcV
aSDvcpLwxKq2QYeS8caPWLQmyszyBrdIvsnrTcUPIG+OOs/w3M+KNYKrySF12hKU
bUujIrBPt+RJ9ptkv28TYRYqnigRZF3nzNnjewIDAQABAoIBAQCqWh2cZ6APrBAX
p0lZXKcpS47+lbQ4CsluMB7qr+829FmnwBUK5KoCjhTYild2UK/VO4eSnn1Hp0c7
sngX325h6w8FYen6AslpPIGWKiEEHtuH8n8iZpwy9Z/TVH+uKGqyS06QCuFnBb1c
mT9aLy0bqhktVqc+NXXjCL9wilW13pAMh56zYQ8oMJUvNLLknttv9dYmuIyZ9hg/
5al4pN7OqzC9N4AAgDjyHIn3N6t6yfBc/kcJ9OdJ1709DYIr6Nl500Nhf+GZkrEX
1KTeWPzV6GQD7FUZTJ5eZWNnLbD03823Q0HCElGQkboCUU65EdVdNEHvGdPZw74d
t2iaXPxxAoGBAPGvd+PByAH98KKeu9z5ysc0AgVOIDTlqhReqMc2jnYTCglWlMcx
al7K0T6QcSTl3Y2xgGo5O7P+MzZkIiKFPx5fX2d9x6CybEcOQ+5bd6fI0hYF8W18
i+i/mmJgGo33UOW6EQfYKAHLn4WdlsKJ9aTaNNCanqkqmS1l+GsrRgYdAoGBANGX
kl/kfGVYOSRh6ztnRc0i3ONo4RZrDgV0bjEmmujc7V5CIDPxhMUkpsOcG8iCt+55
4JqdtLbmfWfeTWWafn8j/Y9DsSv4U0MHc6+Hfit1dmYmZ+ixHjzul9m6H7XsYZ2k
IpNa7RN+MqvB66pHGpTcC8IQ2fNIkK3GtWLaA3x3AoGBAOX90xtcZxbuLzax05jf
5MZYiau+wwtTmtyzj+2zzzIxwBVO3VoJfm4il6jwD5vLW2Dhj5CGUnhg6R9TfuBW
6M/gdounuHcGE+AyhRao2F9EzhfDJBLKuOGOpD4Fsn9y4Psca+SJINlEitO+OZ97
ZdWxCR2SZnYZYZdAOHzTu1lJAoGAJcxK9oYzNOerLneGP6lJOkx+P3jLlwppdexg
bvbCWxp0qFoOiq+UvST1+jLuA8QnPZe3PMsSKyX4GcJKfPdWtsEb2jlf+0kGYwE2
CMLLqzS8zIFCngFLLbvtoLNjQqDFnfNa1O5B8RECPF11jbjS/2OLr0zwsWI1zVEX
pyMgG9MCgYBb+PUIVpo5vRMTsyQ5whRQPK7+5jbU+wFKMnryqfsZ/K6DfeoZzAmn
KhjeRveOiYEfQZfI5GSfm97TKX5hYKQSwOHa9yzTD25iw4aleU8hc4IbqANzbr/c
59KynTtKfZXSb/DAd/FTtFvzfwiin5ss4INKbpuBACDrb+mj1nY6bw==
-----END RSA PRIVATE KEY-----
])
AT_DATA([ssl_cert.pem], [
-----BEGIN CERTIFICATE-----
MIIDgjCCAmoCAQQwDQYJKoZIhvcNAQEFBQAwgYExCzAJBgNVBAYTAlVTMQswCQYD
VQQIEwJDQTEVMBMGA1UEChMMT3BlbiB2U3dpdGNoMREwDwYDVQQLEwhzd2l0Y2hj
YTE7MDkGA1UEAxMyT1ZTIHN3aXRjaGNhIENBIENlcnRpZmljYXRlICgyMDE1IEZl
YiAwOSAwNjoyNjowMykwHhcNMTUwMzEwMTcxMTEzWhcNMjUwMzA3MTcxMTEzWjCB
izELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRUwEwYDVQQKEwxPcGVuIHZTd2l0
Y2gxHzAdBgNVBAsTFk9wZW4gdlN3aXRjaCBjZXJ0aWZpZXIxNzA1BgNVBAMTLmNs
aWVudCBpZDplMWQxNmQ2MS1jMDcwLTQxOWQtOTYxYi00M2Q4YTBkM2IwMzAwggEi
MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDF31mRQr6wFOgRvzHUtKgx9U/D
6XjDD3XkE2f/RNIDvJj6Wr+TXj4VgcV2oH29KHkLRtR2GsTtAnjnVY/w3JMMhS5m
WJ5QHOidfLSFhUFDxtRIZ8WCj/ghZv+0coiVOJnzoapoFzy512JntwXZt5nC/26f
1kc4a1Cu8x3MHsXObNmtonU1sCyvUZfjDR64GM9tTK73qfMF4papfe90RErV10vn
LyEDaRJSyVyLrTMJ/3+O9xVpIO9ykvDEqrZBh5Lxxo9YtCbKzPIGt0i+yetNxQ8g
b446z/Dcz4o1gqvJIXXaEpRtS6MisE+35En2m2S/bxNhFiqeKBFkXefM2eN7AgMB
AAEwDQYJKoZIhvcNAQEFBQADggEBADmkUbvx9zVtcw1/kSMzr184J3xNBZhmJZ39
RBXKR1elZ1aVjc4406vsKZiKKWKQA7rC51xzaLk/huKvUez8RU346GugHtUus05x
7MZ2DDiwJNb7hJBBiJ9a0ZyhwCBcQJj95g3686TWYGpc8eEPldACf38SP2etPOmE
QPvIMm3pztNf6JZDFDoV3cwzVEFhQnDHXQE9sR6eLhxpbQqwVJ8tmAr9F5hRr4i7
SpxHclvZyS+c3nsNb0xluN1Dh8fcy2ITSXfpar+H5B/i1nZA0dBJsW7ChRHAhPQU
QYLXEK2+YnilIr00RMv7qa0vF6vC0lXHjGZhm5GzHW2hXDDUIig=
-----END CERTIFICATE-----
])
AT_CHECK([ovs-vsctl set Open_vSwitch . ssl=@N1 -- --id=@N1 create SSL private_key=ssl_key.pem certificate=ssl_cert.pem bootstrap_ca_cert=true], [0], [ignore])
])



AT_BANNER([ovs-monitor-ipsec (XFRM)])

# This test ensures that ovs-monitor-ipsec would properly parse
# IPsec policies from kernel.
AT_SETUP([Parse "ip xfrm policy" output])
AT_SKIP_IF([test $HAVE_PYTHON = no])
AT_SKIP_IF([$non_ascii_cwd])
OVS_MONITOR_IPSEC_START

AT_DATA([sbin/ip], [#!/bin/sh
echo 'src 192.168.2.128/32 dst 192.168.2.129/32 proto gre
    dir in priority 1794
    mark 1/0x1
    tmpl src 0.0.0.0 dst 0.0.0.0
        proto esp reqid 1 mode transport
src 192.168.2.129/32 dst 192.168.2.128/32 proto gre
    dir out priority 1794
    mark 1/0x1
    tmpl src 0.0.0.0 dst 0.0.0.0
        proto esp reqid 1 mode transport'
])
chmod +x sbin/ip
AT_CHECK([ovs-appctl -t ovs-monitor-ipsec xfrm/policies], [0], [dnl
{'192.168.2.129': [['src 192.168.2.128/32 dst 192.168.2.129/32 proto gre', 'src 192.168.2.128/32 dst 192.168.2.129/32 proto gre']], '192.168.2.128': [['src 192.168.2.129/32 dst 192.168.2.128/32 proto gre', 'src 192.168.2.129/32 dst 192.168.2.128/32 proto gre']]}
])

OVS_MONITOR_IPSEC_STOP
AT_CLEANUP


# This test ensures that ovs-monitor-ipsec would properly parse
# IPsec security associations from kernel.
AT_SETUP([Parse "ip xfrm state" output])
AT_SKIP_IF([test $HAVE_PYTHON = no])
AT_SKIP_IF([$non_ascii_cwd])
OVS_MONITOR_IPSEC_START

AT_DATA([sbin/ip], [#!/bin/sh
echo 'src 192.168.2.129 dst 192.168.2.128
    proto esp spi 0xcdfe5007 reqid 1 mode transport
    replay-window 32
    mark 1/0x1
    aead rfc4106(gcm(aes)) 0x3d7cb9ddde30c4e6a870b9c1474b8795a85e564d 96
    sel src 192.168.2.129/32 dst 192.168.2.128/32
src 192.168.2.128 dst 192.168.2.129
    proto esp spi 0xca623718 reqid 1 mode transport
    replay-window 32
    mark 1/0x1
    aead rfc4106(gcm(aes)) 0x7c5b209afe3c93adae68f544f5a1326320b15fe5 96
    sel src 192.168.2.128/32 dst 192.168.2.129/32'
])
chmod +x sbin/ip
AT_CHECK([ovs-appctl -t ovs-monitor-ipsec xfrm/state], [0], [dnl
{'192.168.2.129': [['sel src 192.168.2.129/32 dst 192.168.2.128/32', 'sel src 192.168.2.128/32 dst 192.168.2.129/32']], '192.168.2.128': [['sel src 192.168.2.129/32 dst 192.168.2.128/32', 'sel src 192.168.2.128/32 dst 192.168.2.129/32']]}
])
OVS_MONITOR_IPSEC_STOP
AT_CLEANUP


AT_BANNER([ovs-monitor-ipsec (strongSwan)])

# This test ensures that ovs-monitor-ipsec would ignore non-IPsec tunnels.
AT_SETUP([Ignore non-IPsec tunnels])
AT_SKIP_IF([test $HAVE_PYTHON = no])
AT_SKIP_IF([$non_ascii_cwd])
OVS_VSWITCHD_START([])
OVS_MONITOR_IPSEC_START

AT_CHECK([ovs-vsctl add-port br0 gre0 -- set interface gre0 type=gre options:remote_ip=1.2.3.4])
# Since ovs-monitor-ipsec does not keep track of non-IPsec tunnels then there
# is no proper way to synchronize this.  If ovs-monitor-ipsec did not
# ignore non-IPsec tunnels then this test would occasionally fail.
AT_CHECK([ovs-appctl -t ovs-monitor-ipsec tunnels/show], [0], [dnl
No tunnels configured with IPsec
])
AT_CHECK([ovs-vsctl del-port br0 gre0])

WAIT_FOR_PROPER_IPSEC_CLEANUP
OVS_MONITOR_IPSEC_STOP
OVS_VSWITCHD_STOP
AT_CLEANUP


# This test ensures that ovs-monitor-ipsec would properly parse
# output from "ipsec status" command
AT_SETUP([Parse "ipsec status" output])
AT_SKIP_IF([test $HAVE_PYTHON = no])
AT_SKIP_IF([$non_ascii_cwd])
OVS_MONITOR_IPSEC_START

AT_DATA([active_tunns], [Routed Connections:
  stt0-out-2{3}:  ROUTED, TRANSPORT
  stt0-out-2{3}:   192.168.2.128/32[[tcp]] === 192.168.2.129/32[[tcp/7471]]
   stt0-in-2{2}:  ROUTED, TRANSPORT
   stt0-in-2{2}:   192.168.2.128/32[[tcp/7471]] === 192.168.2.129/32[[tcp]]
Security Associations (1 up, 0 connecting):
   stt0-in-2[[3]]: ESTABLISHED 3 minutes ago, 192.168.2.128[[192.168.2.128]]...192.168.2.129[[192.168.2.129]]
   stt0-in-2{2}:  INSTALLED, TRANSPORT, ESP SPIs: cbc3e903_i c29b1e5c_o
   stt0-in-2{2}:   192.168.2.128/32[[tcp/7471]] === 192.168.2.129/32[[tcp]]
  stt0-out-2{3}:  INSTALLED, TRANSPORT, ESP SPIs: c958d9fb_i c45ce6b0_o
  stt0-out-2{3}:   192.168.2.128/32[[tcp]] === 192.168.2.129/32[[tcp/7471]]
])

AT_CHECK([ovs-appctl -t ovs-monitor-ipsec ipsec/status], [0], [dnl
{'stt0': {'stt0-in-2[[3]]': 'stt0-in-2[[3]]: ESTABLISHED 3 minutes ago, 192.168.2.128[[192.168.2.128]]...192.168.2.129[[192.168.2.129]]:', 'stt0-in-2{2}': 'stt0-in-2{2}:   192.168.2.128/32[[tcp/7471]] === 192.168.2.129/32[[tcp]]:', 'stt0-out-2{3}': 'stt0-out-2{3}:   192.168.2.128/32[[tcp]] === 192.168.2.129/32[[tcp/7471]]:'}}
])

WAIT_FOR_PROPER_IPSEC_CLEANUP
OVS_MONITOR_IPSEC_STOP
AT_CLEANUP


# This test ensures that ovs-monitor-ipsec would properly configure
# ipsec_gre tunnel with Pre-Shared Key
AT_SETUP([ipsec_gre with PSK authentication])
AT_SKIP_IF([test $HAVE_PYTHON = no])
AT_SKIP_IF([$non_ascii_cwd])
OVS_VSWITCHD_START([])
OVS_MONITOR_IPSEC_START

AT_CHECK([ovs-vsctl add-port br0 gre0 -- \
                    set interface gre0 type=ipsec_gre \
                                       options:remote_ip=1.2.3.4 \
                                       options:psk=swordfish])
WAIT_FOR_TUNNEL_TO_UPDATE([gre0], [1], [CONFIGURED])
AT_CHECK([ovs-appctl -t ovs-monitor-ipsec tunnels/show], [0], [dnl
Interface name: gre0 v1 (CONFIGURED)
  Remote IP:      1.2.3.4
  Tunnel Type:    ipsec_gre
  Local IP:       0.0.0.0
  Use SSL cert:   False
  My cert:        None
  My key:         None
  His cert:       None
  PSK:            swordfish
  Ofport:         1
  CFM state:      Disabled
Kernel policies installed:
Kernel security associations installed:
Strongswan connections that are active:
  gre0-1:

])
AT_CHECK([cat etc/ipsec.secrets], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!

1.2.3.4 : PSK swordfish
])
AT_CHECK([cat etc/ipsec.conf], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!


config setup
    uniqueids=no

conn %default
    keyingtries=%forever
    type=transport
    keyexchange=ikev2
    auto=route
    mark_in=1/1
    ike=aes128gcm12-aesxcbc-modp1024
    esp=aes128gcm12-modp1024

conn gre0-1
    left=0.0.0.0
    right=1.2.3.4
    authby=psk
    leftsubnet=%dynamic[[gre]]
    rightsubnet=%dynamic[[gre]]

])
AT_CHECK([ovs-vsctl del-port gre0])

WAIT_FOR_PROPER_IPSEC_CLEANUP
VERIFY_IPSEC_COMMANDS_EXECUTED([dnl
ipsec restart
ipsec update
ipsec update
ipsec stroke down-nb gre0-1
])
OVS_MONITOR_IPSEC_STOP
OVS_VSWITCHD_STOP
AT_CLEANUP


# This test ensures that ovs-monitor-ipsec would properly configure
# ipsec_stt tunnel with Pre-Shared Key
AT_SETUP([ipsec_stt with PSK authentication])
AT_SKIP_IF([test $HAVE_PYTHON = no])
AT_SKIP_IF([$non_ascii_cwd])
OVS_VSWITCHD_START([])
OVS_MONITOR_IPSEC_START

AT_CHECK([ovs-vsctl add-port br0 stt0 -- \
                    set interface stt0 type=ipsec_stt \
                                       options:remote_ip=1.2.3.4 \
                                       options:psk=swordfish])
WAIT_FOR_TUNNEL_TO_UPDATE([stt0], [1], [CONFIGURED])
AT_CHECK([ovs-appctl -t ovs-monitor-ipsec tunnels/show], [0], [dnl
Interface name: stt0 v1 (CONFIGURED)
  Remote IP:      1.2.3.4
  Tunnel Type:    ipsec_stt
  Local IP:       0.0.0.0
  Use SSL cert:   False
  My cert:        None
  My key:         None
  His cert:       None
  PSK:            swordfish
  Ofport:         1
  CFM state:      Disabled
Kernel policies installed:
Kernel security associations installed:
Strongswan connections that are active:
  stt0-in-1:
  stt0-out-1:

])
AT_CHECK([cat etc/ipsec.secrets], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!

1.2.3.4 : PSK swordfish
])
AT_CHECK([cat etc/ipsec.conf], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!


config setup
    uniqueids=no

conn %default
    keyingtries=%forever
    type=transport
    keyexchange=ikev2
    auto=route
    mark_in=1/1
    ike=aes128gcm12-aesxcbc-modp1024
    esp=aes128gcm12-modp1024

conn stt0-in-1
    left=0.0.0.0
    right=1.2.3.4
    authby=psk
    rightsubnet=%dynamic[[tcp/%any]]
    leftsubnet=%dynamic[[tcp/7471]]

conn stt0-out-1
    left=0.0.0.0
    right=1.2.3.4
    authby=psk
    rightsubnet=%dynamic[[tcp/7471]]
    leftsubnet=%dynamic[[tcp/%any]]

])
AT_CHECK([ovs-vsctl del-port stt0])

WAIT_FOR_PROPER_IPSEC_CLEANUP
VERIFY_IPSEC_COMMANDS_EXECUTED([dnl
ipsec restart
ipsec update
ipsec update
ipsec stroke down-nb stt0-in-1
ipsec stroke down-nb stt0-out-1
])
OVS_MONITOR_IPSEC_STOP
OVS_VSWITCHD_STOP
AT_CLEANUP


# This test ensures that ovs-monitor-ipsec would properly configure
# ipsec_geneve tunnel with Pre-Shared Key
AT_SETUP([ipsec_geneve with PSK authentication])
AT_SKIP_IF([test $HAVE_PYTHON = no])
AT_SKIP_IF([$non_ascii_cwd])
OVS_VSWITCHD_START([])
OVS_MONITOR_IPSEC_START

AT_CHECK([ovs-vsctl add-port br0 geneve0 -- \
                    set interface geneve0 type=ipsec_geneve \
                                       options:remote_ip=1.2.3.4 \
                                       options:psk=swordfish])
WAIT_FOR_TUNNEL_TO_UPDATE([geneve0], [1], [CONFIGURED])
AT_CHECK([ovs-appctl -t ovs-monitor-ipsec tunnels/show], [0], [dnl
Interface name: geneve0 v1 (CONFIGURED)
  Remote IP:      1.2.3.4
  Tunnel Type:    ipsec_geneve
  Local IP:       0.0.0.0
  Use SSL cert:   False
  My cert:        None
  My key:         None
  His cert:       None
  PSK:            swordfish
  Ofport:         1
  CFM state:      Disabled
Kernel policies installed:
Kernel security associations installed:
Strongswan connections that are active:
  geneve0-in-1:
  geneve0-out-1:

])
AT_CHECK([cat etc/ipsec.secrets], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!

1.2.3.4 : PSK swordfish
])
AT_CHECK([cat etc/ipsec.conf], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!


config setup
    uniqueids=no

conn %default
    keyingtries=%forever
    type=transport
    keyexchange=ikev2
    auto=route
    mark_in=1/1
    ike=aes128gcm12-aesxcbc-modp1024
    esp=aes128gcm12-modp1024

conn geneve0-in-1
    left=0.0.0.0
    right=1.2.3.4
    authby=psk
    rightsubnet=%dynamic[[udp/%any]]
    leftsubnet=%dynamic[[udp/6081]]

conn geneve0-out-1
    left=0.0.0.0
    right=1.2.3.4
    authby=psk
    rightsubnet=%dynamic[[udp/6081]]
    leftsubnet=%dynamic[[udp/%any]]

])
AT_CHECK([ovs-vsctl del-port geneve0])

WAIT_FOR_PROPER_IPSEC_CLEANUP
VERIFY_IPSEC_COMMANDS_EXECUTED([dnl
ipsec restart
ipsec update
ipsec update
ipsec stroke down-nb geneve0-in-1
ipsec stroke down-nb geneve0-out-1
])
OVS_MONITOR_IPSEC_STOP
OVS_VSWITCHD_STOP
AT_CLEANUP


# This test ensures that ovs-monitor-ipsec would properly configure
# ipsec_vxlan tunnel with Pre-Shared Key
AT_SETUP([ipsec_vxlan with PSK authentication])
AT_SKIP_IF([test $HAVE_PYTHON = no])
AT_SKIP_IF([$non_ascii_cwd])
OVS_VSWITCHD_START([])
OVS_MONITOR_IPSEC_START

AT_CHECK([ovs-vsctl add-port br0 vxlan0 -- \
                    set interface vxlan0 type=ipsec_vxlan \
                                       options:remote_ip=1.2.3.4 \
                                       options:psk=swordfish])
WAIT_FOR_TUNNEL_TO_UPDATE([vxlan0], [1], [CONFIGURED])
AT_CHECK([ovs-appctl -t ovs-monitor-ipsec tunnels/show], [0], [dnl
Interface name: vxlan0 v1 (CONFIGURED)
  Remote IP:      1.2.3.4
  Tunnel Type:    ipsec_vxlan
  Local IP:       0.0.0.0
  Use SSL cert:   False
  My cert:        None
  My key:         None
  His cert:       None
  PSK:            swordfish
  Ofport:         1
  CFM state:      Disabled
Kernel policies installed:
Kernel security associations installed:
Strongswan connections that are active:
  vxlan0-in-1:
  vxlan0-out-1:

])
AT_CHECK([cat etc/ipsec.secrets], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!

1.2.3.4 : PSK swordfish
])
AT_CHECK([cat etc/ipsec.conf], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!


config setup
    uniqueids=no

conn %default
    keyingtries=%forever
    type=transport
    keyexchange=ikev2
    auto=route
    mark_in=1/1
    ike=aes128gcm12-aesxcbc-modp1024
    esp=aes128gcm12-modp1024

conn vxlan0-in-1
    left=0.0.0.0
    right=1.2.3.4
    authby=psk
    rightsubnet=%dynamic[[udp/%any]]
    leftsubnet=%dynamic[[udp/4789]]

conn vxlan0-out-1
    left=0.0.0.0
    right=1.2.3.4
    authby=psk
    rightsubnet=%dynamic[[udp/4789]]
    leftsubnet=%dynamic[[udp/%any]]

])
AT_CHECK([ovs-vsctl del-port vxlan0])

WAIT_FOR_PROPER_IPSEC_CLEANUP
VERIFY_IPSEC_COMMANDS_EXECUTED([dnl
ipsec restart
ipsec update
ipsec update
ipsec stroke down-nb vxlan0-in-1
ipsec stroke down-nb vxlan0-out-1
])
OVS_MONITOR_IPSEC_STOP
OVS_VSWITCHD_STOP
AT_CLEANUP


# This test ensures that ovs-monitor-ipsec is able to configure IPsec for
# a tunnel that wants to reuse Open vSwitch SSL certificates for
# authentication.  Note that previous PSK tests already verified geneve,
# vxlan and stt IPsec tunneling.  So there is not much benefit of redoing
# these kind of tests for those tunneling protocols.
AT_SETUP([ipsec_gre with PKI authentication (use_ssl_cert)])
AT_SKIP_IF([test $HAVE_PYTHON = no])
AT_SKIP_IF([$non_ascii_cwd])
OVS_VSWITCHD_START([])
OVS_MONITOR_IPSEC_START
INIT_SSL_CERTS

AT_CHECK([ovs-vsctl add-port br0 gre0 -- \
                    set interface gre0 type=ipsec_gre \
                                       options:remote_ip=1.2.3.4 \
                                       options:use_ssl_cert=true \
                                       options:peer_cert="asd"])
WAIT_FOR_TUNNEL_TO_UPDATE([gre0], [1], [CONFIGURED])
AT_CHECK([ovs-appctl -t ovs-monitor-ipsec tunnels/show], [0], [dnl
Interface name: gre0 v1 (CONFIGURED)
  Remote IP:      1.2.3.4
  Tunnel Type:    ipsec_gre
  Local IP:       0.0.0.0
  Use SSL cert:   True
  My cert:        ssl_cert.pem
  My key:         ssl_key.pem
  His cert:       asd
  PSK:            None
  Ofport:         1
  CFM state:      Disabled
Kernel policies installed:
Kernel security associations installed:
Strongswan connections that are active:
  gre0-1:

])
AT_CHECK([cat etc/ipsec.secrets], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!

1.2.3.4 : RSA ssl_key.pem
])
AT_CHECK([cat etc/ipsec.d/certs/ovs-gre0.pem], [0], [dnl
asd])
AT_CHECK([cat etc/ipsec.conf], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!


config setup
    uniqueids=no

conn %default
    keyingtries=%forever
    type=transport
    keyexchange=ikev2
    auto=route
    mark_in=1/1
    ike=aes128gcm12-aesxcbc-modp1024
    esp=aes128gcm12-modp1024

conn gre0-1
    left=0.0.0.0
    right=1.2.3.4
    rightcert=ovs-1.2.3.4.pem
    leftcert=ssl_cert.pem
    leftsubnet=%dynamic[[gre]]
    rightsubnet=%dynamic[[gre]]

])
AT_CHECK([ovs-vsctl del-port gre0])

WAIT_FOR_PROPER_IPSEC_CLEANUP
VERIFY_IPSEC_COMMANDS_EXECUTED([dnl
ipsec restart
ipsec update
ipsec update
ipsec stroke down-nb gre0-1
])
OVS_MONITOR_IPSEC_STOP
OVS_VSWITCHD_STOP
AT_CLEANUP


# This test ensures that ovs-monitor-ipsec would be able to configure
# IPsec tunnel that has it's own Private and Public key (opposed to
# reusing Open vSwitch's SSL credentials)
AT_SETUP([ipsec_gre with PKI authentication])
AT_SKIP_IF([test $HAVE_PYTHON = no])
AT_SKIP_IF([$non_ascii_cwd])
OVS_VSWITCHD_START([])
OVS_MONITOR_IPSEC_START

AT_CHECK([ovs-vsctl add-port br0 gre0 -- \
                    set interface gre0 type=ipsec_gre \
                                       options:remote_ip=1.2.3.4 \
                                       options:private_key="private_key.pem" \
                                       options:certificate="public_key.pem" \
                                       options:peer_cert="asd"])
WAIT_FOR_TUNNEL_TO_UPDATE([gre0], [1], [CONFIGURED])
AT_CHECK([ovs-appctl -t ovs-monitor-ipsec tunnels/show], [0], [dnl
Interface name: gre0 v1 (CONFIGURED)
  Remote IP:      1.2.3.4
  Tunnel Type:    ipsec_gre
  Local IP:       0.0.0.0
  Use SSL cert:   False
  My cert:        public_key.pem
  My key:         private_key.pem
  His cert:       asd
  PSK:            None
  Ofport:         1
  CFM state:      Disabled
Kernel policies installed:
Kernel security associations installed:
Strongswan connections that are active:
  gre0-1:

])
AT_CHECK([cat etc/ipsec.secrets], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!

1.2.3.4 : RSA private_key.pem
])
AT_CHECK([cat etc/ipsec.conf], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!


config setup
    uniqueids=no

conn %default
    keyingtries=%forever
    type=transport
    keyexchange=ikev2
    auto=route
    mark_in=1/1
    ike=aes128gcm12-aesxcbc-modp1024
    esp=aes128gcm12-modp1024

conn gre0-1
    left=0.0.0.0
    right=1.2.3.4
    rightcert=ovs-1.2.3.4.pem
    leftcert=public_key.pem
    leftsubnet=%dynamic[[gre]]
    rightsubnet=%dynamic[[gre]]

])
AT_CHECK([ovs-vsctl del-port gre0])

WAIT_FOR_PROPER_IPSEC_CLEANUP
VERIFY_IPSEC_COMMANDS_EXECUTED([dnl
ipsec restart
ipsec update
ipsec update
ipsec stroke down-nb gre0-1
])
OVS_MONITOR_IPSEC_STOP
OVS_VSWITCHD_STOP
AT_CLEANUP


# This test ensures that ovs-monitor-ipsec is able to configure
# two IPsec tunnels without interfering with each other.
AT_SETUP([ipsec_gre and ipsec_stt to two different hosts])
AT_SKIP_IF([test $HAVE_PYTHON = no])
AT_SKIP_IF([$non_ascii_cwd])
OVS_VSWITCHD_START([])
OVS_MONITOR_IPSEC_START


AT_CHECK([ovs-vsctl add-port br0 gre0 -- \
                    set interface gre0 type=ipsec_gre \
                                       options:remote_ip=1.2.3.4 \
                                       options:private_key="private_key1.pem" \
                                       options:certificate="public_key1.pem" \
                                       options:peer_cert="asd"])
AT_CHECK([ovs-vsctl add-port br0 stt0 -- \
                    set interface stt0 type=ipsec_stt \
                                       options:remote_ip=1.2.3.5 \
                                       options:private_key="private_key2.pem" \
                                       options:certificate="public_key2.pem" \
                                       options:peer_cert="fgh"])
WAIT_FOR_TUNNEL_TO_UPDATE([gre0], [1], [CONFIGURED])
WAIT_FOR_TUNNEL_TO_UPDATE([stt0], [1], [CONFIGURED])
AT_CHECK([cat etc/ipsec.secrets], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!

1.2.3.4 : RSA private_key1.pem
1.2.3.5 : RSA private_key2.pem
])
AT_CHECK([cat etc/ipsec.conf], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!


config setup
    uniqueids=no

conn %default
    keyingtries=%forever
    type=transport
    keyexchange=ikev2
    auto=route
    mark_in=1/1
    ike=aes128gcm12-aesxcbc-modp1024
    esp=aes128gcm12-modp1024

conn gre0-1
    left=0.0.0.0
    right=1.2.3.4
    rightcert=ovs-1.2.3.4.pem
    leftcert=public_key1.pem
    leftsubnet=%dynamic[[gre]]
    rightsubnet=%dynamic[[gre]]

conn stt0-in-1
    left=0.0.0.0
    right=1.2.3.5
    rightcert=ovs-1.2.3.5.pem
    leftcert=public_key2.pem
    rightsubnet=%dynamic[[tcp/%any]]
    leftsubnet=%dynamic[[tcp/7471]]

conn stt0-out-1
    left=0.0.0.0
    right=1.2.3.5
    rightcert=ovs-1.2.3.5.pem
    leftcert=public_key2.pem
    rightsubnet=%dynamic[[tcp/7471]]
    leftsubnet=%dynamic[[tcp/%any]]

])
AT_CHECK([ovs-vsctl del-port gre0])
AT_CHECK([ovs-vsctl del-port stt0])

WAIT_FOR_PROPER_IPSEC_CLEANUP
VERIFY_IPSEC_COMMANDS_EXECUTED([dnl
ipsec restart
ipsec update
ipsec update
ipsec update
ipsec stroke down-nb gre0-1
ipsec update
ipsec stroke down-nb stt0-in-1
ipsec stroke down-nb stt0-out-1
])
OVS_MONITOR_IPSEC_STOP
OVS_VSWITCHD_STOP
AT_CLEANUP


# This test ensures that ovs-monitor-ipsec is able to configure two
# IPsec tunnels simulatenously to the same remote_ip.
AT_SETUP([ipsec_gre and ipsec_stt to the same host])
AT_SKIP_IF([test $HAVE_PYTHON = no])
AT_SKIP_IF([$non_ascii_cwd])
OVS_VSWITCHD_START([])
OVS_MONITOR_IPSEC_START


AT_CHECK([ovs-vsctl add-port br0 gre0 -- \
                    set interface gre0 type=ipsec_gre \
                                       options:remote_ip=1.2.3.4 \
                                       options:private_key="private_key1.pem" \
                                       options:certificate="public_key1.pem" \
                                       options:peer_cert="asd"])
AT_CHECK([ovs-vsctl add-port br0 stt0 -- \
                    set interface stt0 type=ipsec_stt \
                                       options:remote_ip=1.2.3.4 \
                                       options:private_key="private_key2.pem" \
                                       options:certificate="public_key2.pem" \
                                       options:peer_cert="fgh"])
WAIT_FOR_TUNNEL_TO_UPDATE([stt0], [1], [CONFIGURED])
WAIT_FOR_TUNNEL_TO_UPDATE([stt0], [1], [CONFIGURED])
AT_CHECK([cat etc/ipsec.secrets], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!

1.2.3.4 : RSA private_key1.pem
1.2.3.4 : RSA private_key2.pem
])
AT_CHECK([cat etc/ipsec.conf], [0], [dnl
# Generated by ovs-monitor-ipsec...do not modify by hand!


config setup
    uniqueids=no

conn %default
    keyingtries=%forever
    type=transport
    keyexchange=ikev2
    auto=route
    mark_in=1/1
    ike=aes128gcm12-aesxcbc-modp1024
    esp=aes128gcm12-modp1024

conn gre0-1
    left=0.0.0.0
    right=1.2.3.4
    rightcert=ovs-1.2.3.4.pem
    leftcert=public_key1.pem
    leftsubnet=%dynamic[[gre]]
    rightsubnet=%dynamic[[gre]]

conn stt0-in-1
    left=0.0.0.0
    right=1.2.3.4
    rightcert=ovs-1.2.3.4.pem
    leftcert=public_key2.pem
    rightsubnet=%dynamic[[tcp/%any]]
    leftsubnet=%dynamic[[tcp/7471]]

conn stt0-out-1
    left=0.0.0.0
    right=1.2.3.4
    rightcert=ovs-1.2.3.4.pem
    leftcert=public_key2.pem
    rightsubnet=%dynamic[[tcp/7471]]
    leftsubnet=%dynamic[[tcp/%any]]

])
AT_CHECK([ovs-vsctl del-port gre0])
AT_CHECK([ovs-vsctl del-port stt0])

WAIT_FOR_PROPER_IPSEC_CLEANUP
VERIFY_IPSEC_COMMANDS_EXECUTED([dnl
ipsec restart
ipsec update
ipsec update
ipsec update
ipsec stroke down-nb gre0-1
ipsec update
ipsec stroke down-nb stt0-in-1
ipsec stroke down-nb stt0-out-1
])
OVS_MONITOR_IPSEC_STOP
OVS_VSWITCHD_STOP
AT_CLEANUP


# This test ensures that ovs-monitor-ipsec can properly update IPsec tunnel's
# configuration by calling "ipsec update" and "ipsec stroke down-nb"
# commands whenver OVSDB configuration changes.
AT_SETUP([Sequence of IPsec tunnel reconfiguration events])
AT_SKIP_IF([test $HAVE_PYTHON = no])
AT_SKIP_IF([$non_ascii_cwd])
OVS_VSWITCHD_START([])
OVS_MONITOR_IPSEC_START

# Start with tunnel that has 'type' set to 'ipsec_stt' and nothing else
ovs-vsctl add-port br0 tun0 -- set interface tun0 type=ipsec_stt
WAIT_FOR_TUNNEL_TO_UPDATE([tun0], [1], [INVALID])
AT_CHECK([ovs-appctl -t ovs-monitor-ipsec tunnels/show], [0], [dnl
Interface name: tun0 v1 (INVALID: 'remote_ip' is not set)
  Remote IP:      None
  Tunnel Type:    ipsec_stt
  Local IP:       0.0.0.0
  Use SSL cert:   False
  My cert:        None
  My key:         None
  His cert:       None
  PSK:            None
  Ofport:         Not assigned
  CFM state:      Disabled
Kernel policies installed:
Kernel security associations installed:
Strongswan connections that are active:

])

ovs-vsctl set interface tun0 options:remote_ip="1.2.3.4"
WAIT_FOR_TUNNEL_TO_UPDATE([tun0], [2], [INVALID])
AT_CHECK([ovs-appctl -t ovs-monitor-ipsec tunnels/show], [0], [dnl
Interface name: tun0 v2 (INVALID: must set either 'psk' or 'peer_cert')
  Remote IP:      1.2.3.4
  Tunnel Type:    ipsec_stt
  Local IP:       0.0.0.0
  Use SSL cert:   False
  My cert:        None
  My key:         None
  His cert:       None
  PSK:            None
  Ofport:         Not assigned
  CFM state:      Disabled
Kernel policies installed:
Kernel security associations installed:
Strongswan connections that are active:

])

ovs-vsctl set interface tun0 options:psk=swordfish
WAIT_FOR_TUNNEL_TO_UPDATE([tun0], [3], [CONFIGURED])
AT_CHECK([ovs-appctl -t ovs-monitor-ipsec tunnels/show], [0], [dnl
Interface name: tun0 v3 (CONFIGURED)
  Remote IP:      1.2.3.4
  Tunnel Type:    ipsec_stt
  Local IP:       0.0.0.0
  Use SSL cert:   False
  My cert:        None
  My key:         None
  His cert:       None
  PSK:            swordfish
  Ofport:         1
  CFM state:      Disabled
Kernel policies installed:
Kernel security associations installed:
Strongswan connections that are active:
  tun0-out-3:
  tun0-in-3:

])


ovs-vsctl set interface tun0 type=ipsec_gre
WAIT_FOR_TUNNEL_TO_UPDATE([tun0], [4], [CONFIGURED])
AT_CHECK([ovs-appctl -t ovs-monitor-ipsec tunnels/show], [0], [dnl
Interface name: tun0 v4 (CONFIGURED)
  Remote IP:      1.2.3.4
  Tunnel Type:    ipsec_gre
  Local IP:       0.0.0.0
  Use SSL cert:   False
  My cert:        None
  My key:         None
  His cert:       None
  PSK:            swordfish
  Ofport:         1
  CFM state:      Disabled
Kernel policies installed:
Kernel security associations installed:
Strongswan connections that are active:
  tun0-4:

])


ovs-vsctl remove interface tun0 options psk --\
          set Interface tun0 options:peer_cert="asd"
WAIT_FOR_TUNNEL_TO_UPDATE([tun0], [5], [INVALID])
AT_CHECK([ovs-appctl -t ovs-monitor-ipsec tunnels/show], [0], [dnl
Interface name: tun0 v5 (INVALID: must set 'certificate' with PKI)
  Remote IP:      1.2.3.4
  Tunnel Type:    ipsec_gre
  Local IP:       0.0.0.0
  Use SSL cert:   False
  My cert:        None
  My key:         None
  His cert:       asd
  PSK:            None
  Ofport:         Not assigned
  CFM state:      Disabled
Kernel policies installed:
Kernel security associations installed:
Strongswan connections that are active:

])


ovs-vsctl set Interface tun0 options:certificate="my_cert.pem"
WAIT_FOR_TUNNEL_TO_UPDATE([tun0], [6], [INVALID])
AT_CHECK([ovs-appctl -t ovs-monitor-ipsec tunnels/show], [0], [dnl
Interface name: tun0 v6 (INVALID: must set 'private_key' with PKI)
  Remote IP:      1.2.3.4
  Tunnel Type:    ipsec_gre
  Local IP:       0.0.0.0
  Use SSL cert:   False
  My cert:        my_cert.pem
  My key:         None
  His cert:       asd
  PSK:            None
  Ofport:         2
  CFM state:      Disabled
Kernel policies installed:
Kernel security associations installed:
Strongswan connections that are active:

])


ovs-vsctl set Interface tun0 options:private_key="my_key.pem"
WAIT_FOR_TUNNEL_TO_UPDATE([tun0], [7], [CONFIGURED])
AT_CHECK([ovs-appctl -t ovs-monitor-ipsec tunnels/show], [0], [dnl
Interface name: tun0 v7 (CONFIGURED)
  Remote IP:      1.2.3.4
  Tunnel Type:    ipsec_gre
  Local IP:       0.0.0.0
  Use SSL cert:   False
  My cert:        my_cert.pem
  My key:         my_key.pem
  His cert:       asd
  PSK:            None
  Ofport:         2
  CFM state:      Disabled
Kernel policies installed:
Kernel security associations installed:
Strongswan connections that are active:
  tun0-7:

])

AT_CHECK([ovs-vsctl del-port tun0])
WAIT_FOR_PROPER_IPSEC_CLEANUP
VERIFY_IPSEC_COMMANDS_EXECUTED([dnl
ipsec restart
ipsec update
ipsec update
ipsec update
ipsec update
ipsec stroke down-nb tun0-in-3
ipsec stroke down-nb tun0-out-3
ipsec update
ipsec stroke down-nb tun0-4
ipsec update
ipsec update
ipsec update
ipsec stroke down-nb tun0-7
])
# For this test all errors in OVS logs that contain 'netdev' must be ignored
# because ovs-vswitchd also does basic validation
OVS_MONITOR_IPSEC_STOP
OVS_VSWITCHD_STOP(["/netdev/d"])
AT_CLEANUP
